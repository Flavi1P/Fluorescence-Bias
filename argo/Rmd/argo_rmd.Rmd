---
title: "dataset argo/hplc"
author: "Flavien"
date: "27 mars 2019"
output:
  html_document:
    code_folding : hide
    toc : TRUE
    toc_float : TRUE
    toc_depth : 3
    df_print: paged
    include :
      before_body : header.html
      
---
```{r message=FALSE, warning=FALSE, paged.print=FALSE, setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
getwd()
```


```{r package, message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse)
library(readxl)
library(Metrics)
library(vegan)
library(nnls)
library(FactoMineR)
library(DT)
library(sf)
library(grid)
library(gridExtra)
library(ggrepel)
source("functions/phi_lm.R")
source("functions/phi_stat.R")
source("functions/phi_boot.R")
pigments <- c("fuco", "peri", "hex", "but", "allo", "tchlb", "zea")
path = "Data/Longhurst"

map_vec <- read_csv("Data/map_vec")
merged_argo <- read_csv("Data/merged_argo")
```


#Présentation du dataset
***
</br>


Le dataset est composé de 46 flotteurs différents auquels sont associés des mesures d'HPLC concomittantes au premier profil.
La carte ci dessous montre la position du premier profil des flotteurs ainsi que la position de l'HPLC
```{r plot map, echo=FALSE, fig.align="center", fig.cap="**Figure 1 :** Carte de la position des combinaisons flotteurs/HPLC étudiées dans le dataset", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(merged_argo)+
  geom_point(aes(x = lon.x, y = lat.x, colour = "hplc"), size = 3)+
  geom_point(aes(x = lon.y, y = lat.y, colour = "argo"))+
  geom_polygon(aes(x = long, y = lat, group = group), data = map_vec)+
  coord_quickmap()

```

</br>
la liste de flotteurs est la suivante, avec le nombre de mesures associées.
```{r table, message=FALSE, warning=FALSE, paged.print=FALSE}
list_float <- data.frame(table(merged_argo$lovbio))
names(list_float) <- c("flotteur", "nbr_data")
list_float$flotteur <- as.character(list_float$flotteur)
float_unique <- list_float$flotteur[list_float$nbr_data < 3]
list_float <- spread(list_float, key = flotteur, value = nbr_data)
datatable(list_float, rownames = "Nombre de données", options = list(scrollX = TRUE))

merged_argo <- filter(merged_argo, !(lovbio %in% float_unique ))
```
</br>

Sur ces flotteurs un tri a été effectué sur la qualité des données. Les flotteurs avec un QC chlorophylle A de 4 ont été retirés. Au moment du merging entre les profils flotteurs et les données hplc j'ai d'abord appliqué un critère de distance pour sélectionner les profils flotteurs les plus proches des profils hplc, puis j'ai filtré pour garder uniquement les match avec un interval de temps de moins de 24h. Et enfin j'ai retiré les match avec moins de 3 données.</br>
Au final, on obtient le nuage de point suivant lorsque que l'on regarde le fluorescence vs chla hplc.</br>
```{r plot fluo vs chla, echo=FALSE, fig.align="center", fig.cap="**Figure 2 :** Relation entre la fluorescence et la chlorophylla totale du dataset argo/hplc, les coleurs correspondent aux différents flotteurs", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(merged_argo)+
  geom_point(aes(x = tchla, y = chla, colour = lovbio))+
  xlab("total chla hplc") + ylab("fluorescence")+
  theme_bw()
```

#Le ratio fluo/chla par biorégion
***
</br>
Dans l'article de C.Roesler de 2017 l'hypothèse qui est soutenue par les données est que le ratio f/chla dépend des provinces océaniques de Longhurst. Nous proposons ici d'aller plus loin en testant l'hypothèse que cette différence est due à des différences de communautées. </br>
Si cette hypothèse est vérifiée on pourra alors essayer de quantifier l'influence des différentes classes de taille de la communauté.</br>
</br>
J'ai donc associé chaque profil à la province océanique de Longhurst correspondante puis calculé moyenne et écart type du ratio fluo/chla par biorégion.
On trouve des valeurs cohérentes avec celles de Roesler en 2017. On a des ratio très élevés en Austral ainsi qu'en Atalntique subpolaire, avec des valeurs jusqu'à 6. Les valeurs les plus faibles vont parfois en dessous de 1, et correspondent au gyre pacifique sud et au PAcifique ouest. On a quand même des écarts types plus forts qui sont du à un jeu de données plus pauvre que celui de l'article.</br>
```{r column bioregion, message=FALSE, warning=FALSE, paged.print=FALSE}
longhurst_sf <- read_sf(dsn = path.expand(path), quiet = TRUE)

names(longhurst_sf) <- c("code", "region", "geometry")

#longhurst_sf %>% ggplot() + geom_sf(aes(fill = code))

pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(merged_argo),
                                     function(i) {st_point(as.numeric(merged_argo[i,c("lon.x", "lat.x") ]))}), list("crs" = 4326))) 
pnts_trans <- st_transform(pnts_sf, 4326)
longhurst_trans <- st_transform(longhurst_sf, 4326)  
merged_argo$code <- apply(st_intersects(longhurst_trans, pnts_trans, sparse = FALSE), 2, 
                     function(col) { 
                       longhurst_trans[which(col), ]$code
                     })
```

```{r barplot, message=FALSE, warning=FALSE, paged.print=FALSE}
merged_argo <- merged_argo %>% mutate(fluo = chla_adjusted * 2,
                        ratio = fluo/tchla)

region_argo <- merged_argo %>% filter(optical_layer < 4) %>% group_by(code) %>% summarise_at(vars(ratio), c(mean, sd), na.rm = TRUE) %>% ungroup()
names(region_argo) <- c("code", "mean", "sd")
region_argo$sd <- ifelse(region_argo$sd > region_argo$mean, region_argo$mean, region_argo$sd)

codref <- read_excel("Data/Longhurst_Province_Summary.xls", 
                     range = "A17:B70", col_names = FALSE)
names(codref) <- c("code", "region")
region_argo <- left_join(region_argo, codref)

g1 <- ggplot(region_argo)+
  geom_col(aes(x = reorder(code, mean), y = mean, fill = code))+
  geom_errorbar(aes(x = code, ymin = mean - sd, ymax = mean + sd))+
  xlab("code of longhurst oceanic bioregion")+
  geom_errorbar(aes(code, ymax = 2, ymin = 2),
                size=0.5, linetype = "longdash", inherit.aes = F, width = 1)+
  geom_errorbar(aes(code, ymax = 1, ymin = 1),
                size=0.5, linetype = "longdash", inherit.aes = F, width = 1)+
  theme(axis.text.x = element_text(angle = 45))+
  guides(fill = FALSE)+
  scale_fill_brewer(palette = "Set1")

```


```{r afc, message=FALSE, warning=FALSE, paged.print=FALSE}
afc_table <- na.omit(select(merged_argo, pigments, code, micro, nano, pico,  ratio, lon.x, lat.x))
afc_table <- filter(afc_table, code != "ANTA")

afc_argo <- cca(na.omit(select(afc_table, pigments)))
test <- envfit(afc_argo, select(afc_table, micro, nano, pico, ratio))

env_arrow <- as.data.frame(test$vectors$arrows) #On récupère les donnes du modele sur les variables environnementales

argo_score <- as.data.frame(scores(afc_argo, choices = c(1,2,3,4,5), display = c("site"))) #this is a dataframe with the score on the 5 axes of each sample

afc_table <- bind_cols(afc_table, argo_score)

pig_score <- as.data.frame(scores(afc_argo, choices = c(1,2,3,4,5), display = c("species")))
```

```{r map plot,  echo=FALSE, fig.align="center", fig.cap="**Figure 3 :** histogramme de la valeur fluo/chla pour chaque province océanique de Loghurst, les barres noirs correspondent à la moyenne +/- écart type , les pointillés indiquent la valeur 2 et 1. La carte représente la position des profils avec la province en couleur", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
g3 <- ggplot(afc_table)+
  geom_point(aes(x = lon.x, y = lat.x, colour = code), size = 2)+
  geom_polygon(aes(x = long, y = lat, group = group), data = map_vec)+
  xlab("lon")+ylab("lat")+
  coord_quickmap()+
  scale_color_brewer(palette = "Set1")+
  theme_bw()

grid.arrange(g1,g3, ncol = 2)
```
</br>
On cherche alors à tester la correspondance entre les communautées et le ratio. Pour cela on réalise une AFC qui va projeter chaque point dans un plan factoriel à deux axes de façon à résumer au mieux la composition **relative** en pigments. Ici les valeurs d'entrée de l'analyse sont donc les concentrations des 7 pigments diagnostiques. </br>
Sur ce plan factoriel on projette la variable "ratio" qui correspond à la valeur de f/chla, ainsi que les 3 classes de tailles. Ces variables ne vont pas influencer l'analyse mais on pourra voir comment elles se projettent par rapport à la diversité.</br>
Ce qu'on voit en premier c'est que les biorégions se regroupent dans l'espace, ce qui signifie que les biorégions se caractérisent effectivement par des communautés différentes. Mais les biorégions qui ont des ratio similaires se rapprochent également dans l'espace, ce qui indique que le ratio est bien corrélé aux compositions des communautées phytoplanctoniques. On peut également le voir à la taille de la flèche "ratio" qui est du même ordre de grandeur que les trois classes de taille. Le ratio serait donc plus faible dans les communautées dominées par le picophyto. En revanche on a pas de différence de ratio entre une communautée dominée par du nano ou du micro.</br>

```{r afc plot,  echo=FALSE, fig.align="center", fig.cap="**Figure 4 :** AFC sur les 7 pigments diagnostiques du dataset, les couleurs correspondent aux provinces océaniques (cf fig 3). Les flèches en vert correspondent aux variables supplémentaires projetées dans le plan factoriel", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}

ggplot()+
  geom_point(aes(x = CA1, y = CA2, colour = code), size = 2, data = afc_table)+
  geom_segment(aes(x = 0, xend = CA1 *1.5, y = 0, yend = CA2*1.5), data = pig_score)+
  geom_text_repel(aes(x = CA1*1.5, y = CA2*1.5, label = rownames(pig_score)), data = pig_score)+
  geom_segment(aes(x = 0, y = 0, xend = CA1*1.7, yend = CA2*1.7), data = env_arrow, colour = "#33a02c")+
  geom_text(aes(x = CA1*1.7, y = CA2*1.7, label=rownames(env_arrow), fontface = 2), data = env_arrow)+
  scale_color_brewer(palette = "Set1") + coord_equal()+
  coord_equal()
```

</br>
Ces observations supportent notre hypothèse selon laquelle le ratio f/chla dépend des communautées phytoplanctoniques. Nous pouvons donc essayer de quantifier cette variation. Pour cela on cherche à calculer les rendements de fluorescence des 3 classses de tailles phytoplanctoniques.

#Calcul des rendement de fluorescence
***

Comme je l'ai déjà fait pour le jeux de donnée de Biosope ou Boussole je calcul ici les coefficients de rendement par une rérgression multiple.</br>
Le problème est que la faible représentativité des milieux dominés par le pico créer des coefficients négatif pour le pico. Je dois donc forcer les coefficients à être positifs. Pour obtenir des écarts types associés aux coefficients je dois les calculer "à la main".</br>
```{r phi f,  echo=FALSE, fig.align="center", fig.cap="**Figure 5 :** Valeurs des coefficient de rendement de fluorescence associées au trois classes de taille pour les trois couches optiques", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
merged_argo <- filter(merged_argo, optical_layer < 4)

phi_argo <- phi_boot(merged_argo, variable = "fluo")
phi_argo$se <- ifelse(phi_argo$se > phi_argo$phi, phi_argo$phi, phi_argo$se)

ggplot(phi_argo, aes(x=size, y = phi, fill = as.factor(optical_layer))) +
  geom_bar(position=position_dodge(), stat="identity") +
  geom_errorbar(aes(ymin = phi-se, ymax = phi+se),position=position_dodge())+
  scale_fill_viridis_d( name = "optical layer")+
  ylab("Phi")+ xlab("size classe")

phi_argo <- phi_argo %>% select(phi, optical_layer, size) %>% spread(key = size, value = phi)
names(phi_argo) <- c("optical_layer", "phi_micro", "phi_nano", "phi_pico") 
```

</br> Comme pour les autres dataset on a des valeurs plus fortes pour micro et nano. La tendance au sein de la classe de taille micro est également conservée. Il est plus difficile de discuter de l'effet de la profondeur otpique pour les deux autres classes de taille. </br>
On peut néanmoins tester ces coefficients en comparant le RMSE d'une calibration de la fluorescence par un facteur 2 avec le RMSE de la fluorescence calibrée par les $\phi_f$ .
```{r test phi, echo=FALSE, fig.align="center", fig.cap="**Figure 6 :** chlorophylle calibrée en fonction de la chlorophylle a mesurée par hplc, en bleu une calibration par un facteur 2 et en rouge une calibration par les coefficients de rendement ", fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
argo_calibration <- left_join(merged_argo, phi_argo) 

argo_calibration <- argo_calibration %>% mutate(predict_fluo = tchla*(micro*amicro * phi_micro + nano*anano * phi_nano + pico*apico * phi_pico),
                                                calibrate_fluo = (fluo/(micro*amicro * phi_micro + nano*anano * phi_nano + pico*apico * phi_pico))) 

ggplot(filter(argo_calibration, optical_layer < 4))+
  geom_point(aes(x = tchla , y = calibrate_fluo, colour = "calibrate"))+
  geom_point(aes(x = tchla , y = chla_adjusted, colour = "fluo"))+
  geom_line(aes(x = tchla, y = tchla))+
  ylab("chla calibrée") + xlab("tchla hplc")+
  theme_bw()

argo_calibration <- filter(argo_calibration, is.na(calibrate_fluo) == FALSE)
a <- rmse(argo_calibration$tchla, argo_calibration$calibrate_fluo)
b <- rmse(argo_calibration$tchla, argo_calibration$chla_adjusted)
a/b
```

</br> on obtient un rapport entre les deux RMSE de 0.6, ce qui montre que le modèle qui prend en compte les rendement est plus efficace pour calibrer la fluorescence. Ce résultat sera très certainement amélioré par une précision du modèle. </br>
Pour comprendre et visualiser le biais qu'entraine les compostions des communautées phytoplanctoniques dans l'estimation de la concentration en chlorophylle a par la fluorescence on peut modéliser la fluorescence à partir de la concentration en chlorophylle et des proprotions micro/nano/pico.


#Modèlisation de la fluorescence


***
</br>
Pour modéliser la réponse de fluorescence je m'appuie sur l'article de [Brewin en 2010](https://www.sciencedirect.com/science/article/pii/S0304380010001092) qui modélise la composition relative en micro/nano/pico en fonction de la concentration en chlorophylle. Si l'on considère ce modèle efficace pour décrire les communautées à l'échelle globale on peut calculer la fluorescence associée.</br>
```{r modele fluo, echo=FALSE, fig.align="center", fig.cap="**Figure 7 :** composition relative des différentes classes de taille en fonction de la concentration en chlorophylle a. " , fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
phi_argo <- phi_boot(merged_argo, variable = "fluo")
phi_argo$se <- ifelse(phi_argo$se > phi_argo$phi, phi_argo$phi, phi_argo$se)
se_argo <- phi_argo %>% select(se, optical_layer, size) %>% spread(key = size, value = se)
names(se_argo) <- c("optical_layer", "se_micro", "se_nano", "se_pico") 
phi_argo <- phi_argo %>% select(phi, optical_layer, size) %>% spread(key = size, value = phi)
names(phi_argo) <- c("optical_layer", "phi_micro", "phi_nano", "phi_pico") 

d_model <- tibble("tchla" = seq(0, 10, 0.05)) %>% mutate(pico_model = 0.107 * (1 - exp(-6.801 * tchla)),
                                                         pico_nano_model = 1.057 * (1 - exp(-0.851 * tchla)),
                                                         nano_model = pico_nano_model - pico_model,
                                                         micro_model = tchla - (pico_nano_model),
                                                         micro_f = micro_model / tchla,
                                                         nano_f = nano_model /tchla,
                                                         pico_f = pico_model / tchla)
ggplot(filter(d_model, tchla >0))+
  geom_line(aes(x = tchla, y = micro_f, colour = "micro"))+
  geom_line(aes(x = tchla, y = nano_f, colour = "nano"))+
  geom_line(aes(x = tchla, y = pico_f, colour = "pico"))+
  coord_trans(x = "log")+scale_x_continuous(breaks = c(0.01, 0.10, 1, 10))+
  theme_bw()

d_model <- bind_rows(d_model, d_model, d_model)

d_model$optical_layer <- c(rep(1, 201), rep(2,201), rep(3,201))
d_model <- na.omit(d_model)
d_model <- left_join(d_model, phi_argo)
d_model <- left_join(d_model, se_argo)

d_model <- d_model %>% mutate(amicro = 0.0164 * exp(0.79*(optical_layer*0.5)),
                              anano = 0.0876 * exp(-0.45*(optical_layer*0.5)),
                              apico = 0.1393 * exp(-0.69*(optical_layer*0.5)),
                              fluo_model = tchla * (micro_f * amicro * phi_micro + nano_f * anano * phi_nano + pico_f * phi_pico * apico),
                              fluo_min = tchla * (micro_f * amicro * (phi_micro - se_micro) + nano_f * anano * (phi_nano - se_nano) + pico_f * (phi_pico - se_pico) * apico),
                              fluo_max = tchla * (micro_f * amicro * (phi_micro + se_micro) + nano_f * anano * (phi_nano + se_nano) + pico_f * (phi_pico + se_pico) * apico),
                              fluo_f = fluo_model/tchla,
                              fluo_f_min = fluo_min/tchla,
                              fluo_f_max = fluo_max/tchla)



```

```{r plot fluo, echo=FALSE, fig.align="center", fig.cap="**Figure 8 :** Fluorescence modélisée en fonction de la concentration en chlorophylle pour les trois classes de taille. Les traits en pointillés représentent l'écart type associé à chaque modélisation." , fig.height=6, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(filter(d_model, tchla >0))+
  geom_path(aes(x = tchla, y = fluo_f, colour = as.factor(optical_layer)))+
  geom_line(aes(x = tchla, y = fluo_f_min, colour = as.factor(optical_layer)), linetype = 2)+
  geom_line(aes(x = tchla, y = fluo_f_max, colour = as.factor(optical_layer)), linetype = 2)+
  coord_trans(x = "log")+scale_x_continuous(breaks = c(0.01, 0.10, 1, 10))+
  scale_color_brewer(palette = "Set1")+
  ylab("f/chla ratio")+ xlab("Chlorophylle a")+
  theme_bw()
```

</br>
On constate une très forte variation de la fluorescence en fonction de la chlorophylle a (et donc de la composition relative des communautées) mais aussi une forte variabilité entre les couches optiques. Même si effectivement le facteur 2 semble être une valeur moyenne du ratio, une calibration linéaire ne semble pas optimal pour calibrer la fluorescence.